;;; hive-lsp-bridge.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(defun hive-lsp-bridge--find-workspace (project-root)
  "Find the lsp-workspace matching PROJECT-ROOT.\nReturns the workspace object or nil."
  (when (and (featurep 'lsp-mode) (fboundp 'lsp-session))
    (let* ((session (lsp-session))
        (workspaces (lsp--session-workspaces session))
        (result nil))
    (dolist (ws workspaces result) (let* ((root (lsp--workspace-root ws)))
    (when (and root (string-prefix-p (expand-file-name project-root) (expand-file-name root)))
    (setq result ws)))))))

(defun hive-lsp-bridge--ensure-buffer (project-root file-path)
  "Find or open a buffer for FILE-PATH within PROJECT-ROOT workspace.\nReturns the buffer or nil."
  (condition-case err (if file-path (or (find-buffer-visiting (expand-file-name file-path)) (let* ((buf (find-file-noselect (expand-file-name file-path) t)))
    (with-current-buffer buf
    (when (and (featurep 'lsp-mode) (not (lsp-workspaces)))
    (sit-for 0.1)))
    buf)) (let* ((ws (hive-lsp-bridge--find-workspace project-root)))
    (when ws
    (car (lsp--workspace-buffers ws))))) (error nil)))

(defun hive-lsp-bridge--with-lsp-context (project-root file-path callback)
  "Execute CALLBACK in the context of a buffer with active LSP.\nCALLBACK receives the buffer as argument.\nReturns CALLBACK's result or (:error \"...\")."
  (condition-case err (let* ((buf (hive-lsp-bridge--ensure-buffer project-root file-path)))
    (if buf (with-current-buffer buf
    (if (and (featurep 'lsp-mode) (lsp-workspaces)) (funcall callback buf) (list :error "No active LSP workspace in buffer"))) (list :error (format "Cannot find buffer for %s in %s" (or file-path "project") project-root)))) (error (list :error (format "LSP context error: %s" (error-message-string err))))))

(defun hive-lsp-bridge--make-position-params (file-path line column)
  "Build textDocument/position params for FILE-PATH at LINE:COLUMN.\nLINE and COLUMN are 0-based."
  (list :textDocument (list :uri (lsp--path-to-uri (expand-file-name file-path))) :position (lsp-make-position :line line :character column)))

(defun hive-lsp-bridge-status ()
  "Return LSP bridge status.\nResult: (:lsp-available BOOL :workspace-count N :workspaces [...])."
  (condition-case err (if (featurep 'lsp-mode) (let* ((session (lsp-session))
        (workspaces (lsp--session-workspaces session)))
    (list :lsp-available t :workspace-count (length workspaces) :workspaces (mapcar (lambda (ws) (list :root (lsp--workspace-root ws) :server-id (when (lsp--workspace-client ws)
    (lsp--client-server-id (lsp--workspace-client ws))))) workspaces))) (list :lsp-available nil :workspace-count 0 :workspaces '())) (error (list :error (format "Status check failed: %s" (error-message-string err))))))

(defun hive-lsp-bridge-workspaces ()
  "List active LSP workspaces with their roots and server IDs."
  (condition-case err (if (featurep 'lsp-mode) (let* ((session (lsp-session))
        (workspaces (lsp--session-workspaces session)))
    (mapcar (lambda (ws) (list :root (lsp--workspace-root ws) :server-id (when (lsp--workspace-client ws)
    (lsp--client-server-id (lsp--workspace-client ws))) :buffer-count (length (lsp--workspace-buffers ws)))) workspaces)) '()) (error (list :error (format "Workspaces query failed: %s" (error-message-string err))))))

(defun hive-lsp-bridge-hover (project-root file-path line column)
  "Request textDocument/hover at FILE-PATH LINE:COLUMN.\nReturns hover contents or (:error \"...\")."
  (hive-lsp-bridge--with-lsp-context project-root file-path (lambda (_buf) (condition-case err (let* ((params (hive-lsp-bridge--make-position-params file-path line column))
        (result (lsp-request "textDocument/hover" params)))
    (or result (list :error "No hover information"))) (error (list :error (format "Hover request failed: %s" (error-message-string err))))))))

(defun hive-lsp-bridge-definition (project-root file-path line column)
  "Request textDocument/definition at FILE-PATH LINE:COLUMN.\nReturns definition location(s) or (:error \"...\")."
  (hive-lsp-bridge--with-lsp-context project-root file-path (lambda (_buf) (condition-case err (let* ((params (hive-lsp-bridge--make-position-params file-path line column))
        (result (lsp-request "textDocument/definition" params)))
    (or result (list :error "No definition found"))) (error (list :error (format "Definition request failed: %s" (error-message-string err))))))))

(defun hive-lsp-bridge-references (project-root file-path line column)
  "Request textDocument/references at FILE-PATH LINE:COLUMN.\nReturns reference locations or (:error \"...\")."
  (hive-lsp-bridge--with-lsp-context project-root file-path (lambda (_buf) (condition-case err (let* ((params (hive-lsp-bridge--make-position-params file-path line column))
        (ref-params (plist-put params :context (list :includeDeclaration t)))
        (result (lsp-request "textDocument/references" ref-params)))
    (or result (list :error "No references found"))) (error (list :error (format "References request failed: %s" (error-message-string err))))))))

(defun hive-lsp-bridge-document-symbols (project-root file-path)
  "Request textDocument/documentSymbol for FILE-PATH.\nReturns document symbols or (:error \"...\")."
  (hive-lsp-bridge--with-lsp-context project-root file-path (lambda (_buf) (condition-case err (let* ((params (list :textDocument (list :uri (lsp--path-to-uri (expand-file-name file-path)))))
        (result (lsp-request "textDocument/documentSymbol" params)))
    (or result (list :error "No symbols found"))) (error (list :error (format "Document symbols request failed: %s" (error-message-string err))))))))

(defun hive-lsp-bridge-cursor-info (project-root file-path line column)
  "Request clojure/cursorInfo/raw at FILE-PATH LINE:COLUMN.\nReturns cursor info or (:error \"...\")."
  (hive-lsp-bridge--with-lsp-context project-root file-path (lambda (_buf) (condition-case err (let* ((params (hive-lsp-bridge--make-position-params file-path line column))
        (result (lsp-request "clojure/cursorInfo/raw" params)))
    (or result (list :error "No cursor info"))) (error (list :error (format "Cursor info request failed: %s" (error-message-string err))))))))

(defun hive-lsp-bridge-server-info (project-root)
  "Request clojure/serverInfo/raw for the workspace at PROJECT-ROOT.\nReturns server info or (:error \"...\")."
  (hive-lsp-bridge--with-lsp-context project-root nil (lambda (_buf) (condition-case err (let* ((result (lsp-request "clojure/serverInfo/raw" nil)))
    (or result (list :error "No server info"))) (error (list :error (format "Server info request failed: %s" (error-message-string err))))))))

(provide 'hive-lsp-bridge)
;;; hive-lsp-bridge.el ends here
